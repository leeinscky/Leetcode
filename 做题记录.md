# 做题顺序

适合连数据结构都不扎实的菜鸡选手～不要完全按tag！头一次刷，先把这五个tag做了：

**array，string，tree，linkedlist，math**

其它的千万别按tag刷。这样不存在前面答案说的思维暗示问题，反而帮助巩固数据结构，还可以自己归纳某种数据结构的全部技巧～

链接：https://www.zhihu.com/question/36738189/answer/95751126 来源：知乎


# 做题记录（2020年）
| 时间 | 题号|
|:----: |:----:|
| 4.29-5.9 | 十大排序算法, 1-3, 5, 7, 13, 21, 26, 27, 35, 53, 66, 88, 100, 101, 104, 107, 108, 110, 111 （数量：30）|
| 5.10 | 11, 15, 17, 19, 20 |
| 5.11 | 22, 31, 33, 34 |
| 5.12 | 39, 136, 141, 160 |
| 5.16 | 378, 240,     |


# 备忘录
| 题号 | 笔记|
|:----: |:----:|
| 5 | 目前只写了暴力解法，其他的解法还有挺多，之后记得补上 |
| 20 | 还没有完全看完 |
| 22 | 没弄懂 |
| 34 | 没看完 |
| 39 | 没看完 |
|     |     |



# 重要链接
| 主题 | 笔记/链接 |
|:----: |:----:|
| 二分查找 | https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/ |
| B+树 | * [漫画叙述B+树和B-树，很值得看!_网络_菜鸟不会飞-CSDN博客](https://blog.csdn.net/qq_35571554/article/details/82759668?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase) |



# 面试记录
| 面试公司和岗位 | 面试考察内容 |

## 商汤科技 | LC-378: 有序矩阵中第K小的元素
有序矩阵 找第k个最小值 （LC-378）
参考答案：
```java
/*
思路：
1.找出二维矩阵中最小的数left，最大的数right，那么第k小的数必定在left~right之间
2.mid=(left+right) / 2；在二维矩阵中寻找小于等于mid的元素个数count
3.若这个count小于k，表明第k小的数在右半部分且不包含mid，即left=mid+1, right=right，又保证了第k小的数在left~right之间
4.若这个count大于k，表明第k小的数在左半部分且可能包含mid，即left=left, right=mid，又保证了第k小的数在left~right之间
5.因为每次循环中都保证了第k小的数在left~right之间，当left==right时，第k小的数即被找出，等于right

注意：这里的left mid right是数值，不是索引位置。
*/
public class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        //lo:矩阵中最小的数 hi：矩阵中最大的数
        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;// [lo, hi)
        while (lo < hi) {
            // mid：矩阵的中位数
            int mid = lo + (hi - lo) / 2; 
            int count = 0, j = matrix[0].length - 1;//假设矩阵是5x5，j=4

            // 在二维矩阵中寻找小于等于mid的元素个数count
            // 第一个for循环看成从上到下遍历矩阵的每一行
            for (int i = 0; i < matrix.length; i++) {
                //while循环看成对于矩阵的每一行，如果某个元素比中位数大就递减j，直到元素 <= 中位数，最后j的大小代表：这一行中比中位数小的元素个数-1，所以之后要+1
                while (j >= 0 && matrix[i][j] > mid)
                    j--; 
                //count加上当前遍历到的矩阵行的所有小于等于中位数的元素个数，遍历完所有行以后就会得到最终所有的小于等于中位数的元素个数
                count += (j + 1);
            }
            //若这个count小于k，表明第k小的数在右半部分且不包含mid，即left=mid+1, right=right，又保证了第k小的数在left~right之间
            if (count < k) 
                lo = mid + 1;
            //若这个count大于k，表明第k小的数在左半部分且可能包含mid，即left=left, right=mid，又保证了第k小的数在left~right之间
            else
                hi = mid;
        }   
        // 因为每次循环中都保证了第k小的数在left~right之间，当left==right时，第k小的数即被找出，等于right
        return lo;
    }
}
```

解法2:
```java
/* 解法2: 优先队列
思路分析：
https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/378java-er-fen-fa-tu-jie-you-xian-dui-lie-liang-ch/
要找第k小的元素，一种最常规的做法就是使用优先队列。
找第k小的元素，就保留k个最小的元素，其中最大的那个就是答案，所以可以使用最大优先队列。
遍历矩阵中的元素，将元素添加到队列中，如果队列中元素数目MaxPQ.size() > k，就将堆顶最大的元素弹出。
遍历结束后弹出堆顶元素，就是最小的k个元素中最大的，即第k小的元素。

这里可以利用矩阵的有序性做一点小的优化：
如果在遍历的过程中，队列中的元素数目已经为k了，且如果当前元素大于堆顶元素，这个元素放入队列中还会被弹出，所以就没必要放入。
并且遍历的内循环是从某一行的从左到右遍历，当前元素的右边元素比当前元素更大，也没必要放入队列，
所以当MaxPQ.size() == k && num > MaxPQ.peek()，直接打断内循环，进行下一行的遍历。

时间复杂度为O(n^2log(k))，空间复杂度为O(k)。
*/

public class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        // PriorityQueue默认是一个小顶堆（堆顶到堆底从小到大），通过使用reverseOrder() 可以实现大顶堆(堆顶到堆底从大到小)
        PriorityQueue<Integer> MaxPQ = new PriorityQueue<>(Collections.reverseOrder());
        for (int[] row : matrix) {
            for (int num : row) {
                if (MaxPQ.size() == k && num > MaxPQ.peek()) // peek() 用于在队列的头部查询元素
                    break;
                MaxPQ.add(num);
                if (MaxPQ.size() > k)
                    MaxPQ.remove();// 从队列中删除第一个元素
            }
        }
        return MaxPQ.remove();// 从队列中删除第一个元素 也就是矩阵中第k小的数
    }
}

/*
 * 2、poll()和remove()区别：
 * remove() 和 poll() 方法都是从队列中删除第一个元素。如果队列元素为空，调用remove() 的行为与 Collection
 * 接口的版本相似会抛出异常，但是新的 poll() 方法在用空集合调用时只是返回 null。因此新的方法更适合容易出现异常条件的情况。
 */

```



## 百度 NLP | LC-240: 搜索mxn矩阵中的一个目标值target
从列表中找到某个目标值（我的思路：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/）
```java

/*
方法一：暴力法 对于每一行我们可以像搜索未排序的一维数组——通过检查每个元素来判断是否有目标值。
算法：这个算法并没有做到聪明的事情。我们循环数组，依次检查每个元素。
如果，我们找到了，我们返回 true。否则，对于搜索到末尾都没有返回的循环，我们返回 false。
此算法在所有情况下都是正确的答案，因为我们耗尽了整个搜索空间。
*/
/*
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == target) {
                    return true;
                }
            }
        }
        return false;
    }
}
*/
//复杂度分析:时间复杂度: O(mn)。因为我们在n×m 矩阵上操作，总的时间复杂度为矩阵的大小 
//空间复杂度：O(1)，暴力法分配的额外空间不超过少量指针，因此内存占用是恒定的。


/*
方法二：二分法搜索
矩阵已经排过序，就需要使用二分法搜索以加快我们的算法。

算法：首先，我们确保矩阵不为空。那么，如果我们迭代矩阵对角线，从当前元素对列和行搜索，
我们可以保持从当前 (row,col)(row,col) 对开始的行和列为已排序。 因此，我们总是可以二分搜索这些行和列切片。

我们以如下逻辑的方式进行 : 在对角线上迭代，二分搜索行和列，直到对角线的迭代元素用完为止（意味着我们可以返回 false ）
或者找到目标（意味着我们可以返回 true ）。

binary search 函数的工作原理和普通的二分搜索一样,但需要同时搜索二维数组的行和列。
*/
/*
class Solution {
    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) {//start:0,1,2
        int lo = start; // start:0,1,2
        //如果vertical=true，说明搜索列，hi=矩阵的列数-1 ；否则hi=矩阵行数-1
        int hi = vertical ? matrix[0].length-1 : matrix.length-1;

        while (lo <= hi) {
            int mid = (lo + hi)/2;
            if (vertical) { // searching a column 行不变二分法搜索某列
                if (matrix[start][mid] < target) {//matrix[0][mid] matrix[1][mid] matrix[2][mid] 一共三行
                    lo = mid + 1;
                } else if (matrix[start][mid] > target) {
                    hi = mid - 1;
                } else {
                    return true;
                }
            
            } else { // searching a row 搜索某行
                if (matrix[mid][start] < target) {//matrix[mid][0] matrix[mid][1] matrix[mid][2] 一共三列
                    lo = mid + 1;
                } else if (matrix[mid][start] > target) {
                    hi = mid - 1;
                } else {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean searchMatrix(int[][] matrix, int target) {
        // an empty matrix obviously does not contain `target`
        if (matrix == null || matrix.length == 0) {
            return false;
        }

        // iterate over matrix diagonals matrix.length:获取行数 matrix[0].length:获取列数
        // 二维数组可以理解为是一维数组，只不过他的各处的元素是特殊元素—–一维数组
        int shorterDim = Math.min(matrix.length, matrix[0].length);

        for (int i = 0; i < shorterDim; i++) {  //假设矩阵5行3列 shorterDim=3
            boolean verticalFound = binarySearch(matrix, target, i, true);
            boolean horizontalFound = binarySearch(matrix, target, i, false);
            if (verticalFound || horizontalFound) {
                return true;
            }
        }
        return false; 
    }
}
*/

/*
 * 方法二如果不运行horizontalFound 只运行verticalFound Testcase [[5],[6]] 6 Answer false
 * Expected Answer true
 */


/*
 * 方法四： 因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)或O(n)元素。
 * 
 * 算法： 首先，我们初始化一个指向矩阵左下角的(row，col)指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的
 * (row，col)为止，我们执行以下操作：
 * 1. 如果当前指向的值大于目标值，则可以 “向上” 移动一行。
 * 2. 否则，如果当前指向的值小于目标值，则可以移动一列。
 * 这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。
 * 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大，就没有必要再往右移动了，应该向上移动一行
 * 
 * 也可以对列进行非常类似的论证：当前值的上侧肯定比当前值小，所以没必要向上移动一行，应该往右移动一列
 * 因此这种搜索方式将始终在矩阵中找到目标（如果存在）。
 */


class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // start our "pointer" in the bottom-left 指针初始化在左下角
        int row = matrix.length-1; //指向最后一行
        int col = 0;

        while (row >= 0 && col < matrix[0].length) {
            if (matrix[row][col] > target) { 
                row--;
            } else if (matrix[row][col] < target) {
                col++;
            } else { // found it
                return true;
            }
        }
        return false;
    }
}

/*
 * 时间复杂度：O(n+m)。 时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少
 * mm 次，而列只能增加 nn 次，因此在导致 while 循环终止之前，循环不能运行超过 n+mn+m
 * 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。
 * 空间复杂度：O(1)，因为这种方法只处理几个指针，所以它的内存占用是恒定的。
 */

```


## 滴滴 | LC-1: 两数之和
[1, 2, 7, 3, 4, 6, 4]  2个数的和等于某一个数的所有组合。
```java
list = [4, 6, 4] 
sum = 10
//正解：

/* 方法一：暴力法
暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。
复杂度分析：时间复杂度：O(n^2))对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n 
2)。空间复杂度：O(1)。
 */
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++){
            for (int j = i + 1; j < nums.length; j++){
                if (nums[i] + nums[j] == target){
                    return new int[] {i, j};
                }

            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}

/*
 * 方法二：两遍哈希表  
 * 复杂度分析： 时间复杂度：O(n)O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为
 * O(n)O(n)。 空间复杂度：O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。
 */
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) && map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}

/*
 * 方法三：一遍哈希表
 * 事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，
 * 那我们已经找到了对应解，并立即将其返回。 
 * 复杂度分析：
 * 时间复杂度：O(n)， 我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。
 * 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。
 */
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
``` 

## 商汤 容器平台 云平台开发工程师 | LC-1: 两数之和
问题：[1, 2, 7, 3, 4, 6, 4] 找出2个数的和等于某一个数的所有组合。
```java
list = [4, 6, 4] 
sum = 10
//正解：

/* 方法一：暴力法
暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。
复杂度分析：时间复杂度：O(n^2))对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n 
2)。空间复杂度：O(1)。
 */
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++){
            for (int j = i + 1; j < nums.length; j++){
                if (nums[i] + nums[j] == target){
                    return new int[] {i, j};
                }

            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}

/*
 * 方法二：两遍哈希表  
 * 复杂度分析： 时间复杂度：O(n)O(n)， 我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为
 * O(n)O(n)。 空间复杂度：O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。
 */
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement) && map.get(complement) != i) {
                return new int[] { i, map.get(complement) };
            }
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}

/*
 * 方法三：一遍哈希表
 * 事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，
 * 那我们已经找到了对应解，并立即将其返回。 
 * 复杂度分析：
 * 时间复杂度：O(n)， 我们只遍历了包含有n个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。
 * 空间复杂度：O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。
 */
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
``` 

## 旷视科技 | 1-10000 找出所有质数

```java
/* 思路一：这个数与除1之外小于它的数取余不为0，则这个数为质数
质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。 
由以上的定义我们可以延伸出另一种解释：这个数与除1之外小于它的数取余不为0，则这个数为质数。那么由此分析，解决这个问题需要用到循环结构，且需要嵌套。 
*/
class TestLoopNest{  
    public static void main(String[] args){  
        boolean b = true;//用来表示“这个数”是否为质数  
        for(int i = 2;i <= 10000;i ++){//100以内数的遍历  
            //判断其是否为质数  
            for(int j = 2;j < i;j ++){  
                if(i % j == 0){  
                    b = false;  
                }  
            }  
            if(b){//如果b为true，则输出i  
                System.out.println(i);  
            }  
            b = true;//当判断完一个数之后，b的值重新赋成true  
        }  
    }  
}  

//思路2：利用了break跳出循环，只要找到i%j == 0的值 循环就会跳出，速度较快 
public class TestPrimeNum { //已运行验证
    public static void main(String[] args) {
        boolean flag02 = true;
        long start02 = System.currentTimeMillis();

        for (int i = 2; i < 100; i++) {
            for (int j = 2; j < i; j++) {
                if (i % j == 0) {
                    flag02 = false;
                    break; //对于当前数i，只要有一个j满足i % j == 0，即j是i的因数，就退出循环
                }
            }
            if (flag02 == true) {
                System.out.println(i);
            }
            flag02 = true;
        }

        long end02 = System.currentTimeMillis();
        System.out.println("经历的时间为：" + (end02 - start02));
    }
}


/* 思路三：只需要找到j开平方的值就可以判定是不是素数，说到这里大家可能有点不太理解，例如：17这个数字，17开平方的值为4点多，当i的值无法被17整除的时候，他的平方根的值也一定不能被整除。大家仔细考虑一下。*/

public class TestPrimeNum {
    public static void main(String[] args){
        //方法三
        boolean flag03 = false;
        long start03 = System.currentTimeMillis();
        for(int i = 2; i < 100000; i++){
            for(int j = 2; j <= Math.sqrt(i); j++){
                if(i % j == 0){
                    flag03 = true;
                    break;
                }
            }
            if(flag03 == false){
                System.out.println(i);
            }
        }

        long end03 = System.currentTimeMillis();
        System.out.println("经历的时间为：" + (end03 - start03));
    }
}




```